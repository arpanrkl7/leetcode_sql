1917. Leetcodify Friends Recommendations
Table: Friendship
Column Name	Type
user1_id	int
user2_id	int

(user1_id, user2_id) is the primary key of this table.

Each row indicates that user1_id and user2_id are friends.

Friendship is bidirectional:

If (a, b) is in the table, then (b, a) is also considered a friendship.

However, the table contains only one direction of each friendship pair.

Table: Likes
Column Name	Type
user_id	int
song_id	int
day	date

(user_id, song_id, day) is the primary key of this table.

Each row indicates that user_id liked song_id on a specific day.

Task

Write an SQL query to recommend friends on Leetcodify.

Two users x and y should be recommended to each other if:

x and y are not friends, and

They have listened to (liked) the same song on the same day

Output

Return a table with the following columns:

user1_id

user2_id

Rules

user1_id < user2_id

Return each pair only once

Return the result table in any order

Example
Input

Friendship

user1_id	user2_id
1	2

Likes

user_id	song_id	day
1	10	2021-03-15
2	10	2021-03-15
3	10	2021-03-15
1	20	2021-03-16
3	20	2021-03-16
Output
user1_id	user2_id
1	3
2	3

Solution 1
----------
WITH pairs AS (
  SELECT
    l1.user_id AS u1,
    l2.user_id AS u2
  FROM Listens l1
  JOIN Listens l2
    ON l1.song_id = l2.song_id
   AND l1.day = l2.day
   AND l1.user_id < l2.user_id
  GROUP BY l1.day, l1.user_id, l2.user_id
  HAVING COUNT(DISTINCT l1.song_id) >= 3
),
not_friends AS (
  SELECT p.u1, p.u2
  FROM pairs p
  WHERE NOT EXISTS (
    SELECT 1
    FROM Friendship f
    WHERE f.user1_id = p.u1 AND f.user2_id = p.u2
  )
)
SELECT u1 AS user_id, u2 AS recommended_id
FROM not_friends
UNION
SELECT u2 AS user_id, u1 AS recommended_id
FROM not_friends;


Solution 2
----------
# Solution with two CTEs and simple JOIN
WITH friends AS (
    SELECT user1_id AS user1, user2_id AS user2 FROM friendship
    UNION
    SELECT user2_id AS user1, user1_id AS user2 FROM friendship
)
, listen_count AS (
    SELECT
        l1.user_id AS user1,
        l2.user_id AS user2,
        l1.day
    FROM listens l1
    JOIN listens l2 ON 
        l1.user_id <> l2.user_id AND 
        l1.song_id = l2.song_id AND 
        l1.day = l2.day
    GROUP BY l1.user_id, l2.user_id, l1.day
    HAVING COUNT(DISTINCT l1.song_id) >= 3
)

SELECT 
    DISTINCT a.user1 as user_id,
    a.user2 as recommended_id
FROM listen_count a
LEFT JOIN friends f ON a.user1 = f.user1 AND a.user2 = f.user2
WHERE f.user1 IS NULL;
