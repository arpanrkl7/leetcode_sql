1919. Leetcodify Similar Friends
Table: Friendship
Column Name	Type
user1_id	int
user2_id	int

(user1_id, user2_id) is the primary key of this table.

Each row indicates that user1_id and user2_id are friends.

Friendship is bidirectional:

If (a, b) is in the table, then (b, a) is also considered a friendship.

The table stores only one direction of each friendship pair.

Table: Listens
Column Name	Type
user_id	int
song_id	int
day	date

(user_id, song_id, day) is the primary key of this table.

Each row indicates that user_id listened to song_id on a specific day.

Definition: Similar Friends

Two users x and y are considered similar friends if:

x and y are friends, and

They listened to at least three different songs on the same day

Task

Write an SQL query to report all pairs of similar friends.

Output Requirements

Return the result table with columns:

user1_id

user2_id

Ensure user1_id < user2_id

Return each pair only once

Return the result table in any order

Example
Input

Friendship

user1_id	user2_id
1	2
1	3
2	3

Listens

user_id	song_id	day
1	10	2021-03-15
2	10	2021-03-15
1	11	2021-03-15
2	11	2021-03-15
1	12	2021-03-15
2	12	2021-03-15
1	13	2021-03-16
3	13	2021-03-16
Output
user1_id	user2_id
1	2
Explanation

Users 1 and 2 are friends

On 2021-03-15, they listened to songs {10, 11, 12} â†’ 3 different songs on the same day

Pair (1, 2) qualifies

Other friend pairs do not meet the criteria

Solution 1
-----------
# Solution with UNION and sub-query
WITH friends AS (
    SELECT user1_id AS user1, user2_id AS user2 FROM friendship
    UNION
    SELECT user2_id AS user1, user1_id AS user2 FROM friendship
)
,listen_count AS(
    SELECT
        l1.user_id AS user1,
        l2.user_id AS user2,
        l1.day
    FROM listens l1
    JOIN listens l2 ON 
        l1.user_id <> l2.user_id AND 
        l1.song_id = l2.song_id AND 
        l1.day = l2.day
    GROUP BY l1.user_id, l2.user_id, l1.day
    HAVING COUNT(DISTINCT l1.song_id) >= 3
)

SELECT 
    DISTINCT lc.user1 AS user1_id,
    lc.user2 AS user2_id
FROM listen_count lc
WHERE (lc.user1, lc.user2) IN (
    SELECT user1_id, user2_id FROM friendship
);

Solution 2
-----------
# Solution with JOIN and without UNION
WITH listen_count AS(
    SELECT
        l1.user_id AS user1,
        l2.user_id AS user2,
        l1.day
    FROM listens l1
    JOIN listens l2 ON 
        l1.user_id <> l2.user_id AND 
        l1.song_id = l2.song_id AND 
        l1.day = l2.day
    GROUP BY l1.user_id, l2.user_id, l1.day
    HAVING COUNT(DISTINCT l1.song_id) >= 3
)

SELECT 
    DISTINCT lc.user1 AS user1_id,
    lc.user2 AS user2_id
FROM listen_count lc
LEFT JOIN friendship f ON 
    lc.user1 = f.user1_id AND 
    lc.user2 = f.user2_id
WHERE f.user1_id IS NOT NULL;
